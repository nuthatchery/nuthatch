testsuite Floating-point literals
topsort FloatLiteral

test 3.10.2-i1: Whole or fractional part must have a digit
  ".e2" fails
  
test 3.10.2-i2: Whole or fractional part must have a digit
  ".F" fails

test ExponentPart must include a SignedInteger
  "1.E" fails
  
test ExponentPart must include a SignedInteger
  "1.e" fails

test ExponentPart must include a SignedInteger
  "1.E+" fails
  
test ExponentPart must include a SignedInteger
  "1.E-" fails
  
test ExponentPart must include a SignedInteger
  ".1eF" fails
  
test ExponentPart must include a SignedInteger
  ".1e-D" fails
  
test ExponentPart must include a SignedInteger
  "1e-d" fails
  
test ExponentPart must include a SignedInteger
  ".1e+F" fails

test 3.10.2-float-1: example float literal
  "1e1f" succeeds

test 3.10.2-float-2: example float literal
  "2.f" succeeds

test 3.10.2-float-3: example float literal
  "1.e-1" succeeds

test 3.10.2-float-4: example float literal
  ".3F" succeeds

test 3.10.2-float-5: example float literal
  "0f" succeeds

test 3.10.2-float-6: example float literal
  "3.14f" succeeds

test 3.10.2-float-7: example float literal
  "6.022137e+23f" succeeds

test 3.10.2-float-8: largest finite float, by JLS
  "3.40282347e+38f" succeeds

test 3.10.2-float-9: smallest finite float
  "1.40239846e-45f" succeeds

test 3.10.2-float-10: extra 0s don't affect floating point parsing
  "000000000000000000000000000000000000000000000000000000000000000000000000.000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000e00000000000000000000000000000000050f" succeeds

/**
 * tcltest::test 3.10.2-float-11 { unicode 1e0F } {
 *   literal T3102f11 {\u0031\u0065\u0030\u0046}
 * } PASS
 */

test 3.10.2-double-1 { example double literal } {
  "1E1D" succeeds

test 3.10.2-double-2 { example double literal } {
  "2." succeeds

test 3.10.2-double-3 { example double literal } {
  ".3" succeeds

test 3.10.2-double-4 { example double literal } {
  "0.0" succeeds

test 3.10.2-double-5 { example double literal } {
  "3.14" succeeds

test 3.10.2-double-6 { example double literal } {
  "1e-9d" succeeds

test 3.10.2-double-7 { example double literal } {
  "1e137" succeeds

/**
 * tcltest::test 3.10.2-double-12 { unicode escape the . in float 1.0 } {
 *    literal T3102d12 1\u002e0
 * } PASS
 */

test 3.10.2-double-15: valid double overrides invalid octal
  "08." succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09." succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08e0" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09e0" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08.d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09.d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08e0d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09e0d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09d" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08.D" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09.D" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08e0D" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09e0D" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "08D" succeeds

test 3.10.2-double-15: valid double overrides invalid octal
  "09D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180." succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190." succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180e0" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190e0" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180.d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190.d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180e0d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190e0d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190d" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180.D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190.D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180e0D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190e0D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0180D" succeeds

test 3.10.2-double-16: valid double overrides invalid octal
  "0190D" succeeds

test 3.10.2-double-17: check for 0 followed by letter
  "0e+0d" -> Float(_)
  
test 3.10.2-double-17: check for 0 followed by letter  
  "0e-0d" -> Float(_)
 