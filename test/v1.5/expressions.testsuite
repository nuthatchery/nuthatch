testsuite Java Expressions
topsort Expr

test null literal
  "null" -> Lit(Null())

test simple int literal
  "5" -> Lit(Deci("5"))

test simple char literal
 " 'a' " -> Lit(Char(Single(97)))

test char literal with escape lf
  " '\n' " -> Lit(Char(NamedEscape(110)))

test char literal with unicode escape
  " '\u0061' " -> Lit(Char(UnicodeEscape([117],48,48,54,49)))

test string literal with lots of unicode escapes
  [ "\u01c2\u01c2\u01c1\u012c\u012b\u01a0\u01f8\u02dc\u025f\u02ee\u0215 "]
  succeeds

test string literal with lots of unicode escapes
  [ "\ufe8f\u0344\uff85\uff65\ufdb5\ufda1\033\u02c4\034G\ufea8" ]
  succeeds

test 0F
  "0F" -> Lit(Float("0F"))

test simple addition
  "2 + 3" -> Plus(Lit(Deci("2")), Lit(Deci("3")))

test always take longest match for --
  "1--2" fails

test simple pre increment
  "++2" -> PreIncr(Lit(Deci("2")))

test simple post increment
  "2++" -> PostIncr(Lit(Deci("2")))

test simple pre decrement
  "--2" -> PreDecr(Lit(Deci("2")))

test simple post decrement
  "2--" -> PostDecr(Lit(Deci("2")))

test addition is left associative
  "1 + 2 + 3" -> Plus(Plus(_, _), _)

test multiplication has higher priority than addition
  "1 + 2 * 3" -> Plus(_, Mul(_, _))

test unary operators 1
  "!++x" -> Not(PreIncr(_))

test unary operators 2
  "!+x" -> Not(Plus(_))

test unary operators 3
  "-!x" -> Minus(Not(_))

test unary operators 4
  "!-x" -> Not(Minus(_))

test unary operators 5
  "!x++" -> Not(PostIncr(_))

test Cast operators 1
  "(int) -1" -> CastPrim(_, Minus(_))

test Cast operators 2
  " (int) ++1 " -> CastPrim(_, PreIncr(_))

test Cast operators 3
  " (byte)~mask " -> CastPrim(_, Complement(_))

test Cast operators 4
  " ~(byte)mask " -> Complement(CastPrim(_, _))

test Cast operators 5
  " ~(byte)~mask " -> Complement(CastPrim(_, Complement(_)))

test Cast operators 6
  " (Foo) + 2" -> Plus(ExprName(Id("Foo")), Lit(Deci("2")))

test Cast operators 7
  " (int) + 2" -> CastPrim(_, Plus(Lit(Deci("2"))))

test Cast operators 8
  "(String) -1 " -> Minus(ExprName(Id("String")),Lit(Deci("1")))

test Cast operators 9
  "(String) ++1" fails

test Cast operators 10
  "(String) 1++" -> CastRef(_, PostIncr(_))

test Cast operators 11
  " (int)1 + 2" -> Plus(CastPrim(_, _), Lit(Deci("2")))

test Cast operators 12
  " (int)1 * 2" -> Mul(CastPrim(_, _), Lit(Deci("2")))

test Cast operators 13
  " (int)1 == 2" -> Eq(CastPrim(_, _), Lit(Deci("2")))

test simple array creation expression
  "new int[3]" -> NewArray(Int,[Dim(Lit(Deci("3")))],[])

test 2 dimensional array creation expression
  "new int[3][4]" succeeds

test array creation with initializer
  "new int[]{1,2,3,4}" succeeds

test array initializer with stupid comma
  "new int[]{1,2,3,4,}" succeeds

test two dimensional array initializer
  "new int[][]{{1,2},{3,4}}" succeeds

test two dimensional array initializer with null
  "new int[][]{{1,2},{3,4}, null}" succeeds

test illegal array access
  "new int[3][4][][2]" fails

test relational operators have higher priority than equational ones
  "1 < 2 == 3 < 4" -> Eq(Lt(_, _), Lt(_, _))

test priority of cast is higher the plus minus expressions
  "1 + (n) + 3 + 4" ->
  Plus(
    Plus(
      Plus(
        Lit(Deci("1"))
      , ExprName(Id("n"))
      )
    , Lit(Deci("3"))
    )
  , Lit(Deci("4"))
  )

test simple name
  "x" -> ExprName(Id("x"))

test post increment has higher priority than pre increment
  "++ 1 ++" -> PreIncr(PostIncr(Lit(Deci("1"))))

test simple assignment
  "x = 1" -> Assign(ExprName(Id("x")), Lit(Deci("1")))

test Field access on expression
  "blaat().field" -> Field(Invoke(Method(MethodName(Id("blaat"))), []), Id("field"))

test Simple method invocation
  "method()" -> Invoke(Method(MethodName(Id("method"))), [])

test Simple method invocation on var
  "var.method()" -> Invoke(Method(MethodName(AmbName([Id("var")]), Id("method"))), [])

test Simple method invocation on var of class Foo
  "Foo.var.method()" -> Invoke(Method(MethodName(AmbName([Id("Foo"), Id("var")]), Id("method"))), [])

test Method invocation has higher priority than assignment
  "x = var.method()" -> Assign(ExprName(Id("x")), Invoke(Method(MethodName(AmbName([Id("var")]), Id("method"))), []))

test Simple literal
  [ "Literal" ] -> Lit(String([Chars("Literal")]))

test Method invocation has higher priority than assignment
  "country = _loader.getname(countryID)" ->
      Assign(ExprName(Id("country")), Invoke(Method(MethodName(_, Id("getname"))), [ExprName(Id("countryID"))]))

test Method invocation has higher priority than addition
  [ "Literal" + " Literal ".trim() ] ->
      Plus(Lit(_), Invoke(Method(Lit(_), None(), Id("trim")), []))

test Prefer a methodname over an expression
  "blaat.trim()" -> Invoke(Method(MethodName(AmbName([Id("blaat")]), Id("trim"))), [])

test field access has higher priority than addition
  [ "Literal" + " Literal ".notreallyafield ] ->
      Plus(Lit(String([Chars("Literal")])), Field(Lit(String([Chars(" Literal ")])), Id("notreallyafield")))

test method invocations
  "x.blaat1().blaat2().blaat3()" ->
    Invoke(
      Method(
        Invoke(
          Method(
            Invoke(
              Method(MethodName(AmbName([Id("x")]), Id("blaat1"))), []
            )
          , None()
          , Id("blaat2")
          )
        , []
        )
      , None()
      , Id("blaat3")
      )
    , []
    )

test Mod
  "i % radix" succeeds

test Minus
  "-(i % radix)" succeeds

test Array subscript 0
  " buf[x] " -> ArrayAccess(ExprName(Id("buf")), ExprName(Id("x")))

test Array subscript 1
  "buf[charPos--]" succeeds

test Array subscript 2
  "digits[-(i % radix)]" succeeds
