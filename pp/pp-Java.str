module pp-Java
imports
  liblib
  Box
  Java-15
  concrete-syntax
  pp-Java-Statements
  pp-Java-Expressions
  pp-Java-Literals 
  pp-Java-Names
  pp-Java-Modifiers

  // types
  pp-Java-ParameterizedTypes
  pp-Java-PrimitiveTypes
  pp-Java-ReferenceTypes

  // interfaces
  pp-Java-Annotations

strategies

  java-pretty-print = 
      topdown(try(repeat(java-to-box)))
    ; concat-content

strategies

  java-to-box: Void() -> box |[ KW["void"] ]|

  java-to-box:
    CompilationUnit(Some(package), imports, types) -> box |[ V vs=1 [~package V vs=0 [ ~*imports ] V vs=1 [ ~*types ]] ]|

  java-to-box:
    CompilationUnit(None(), imports, types) -> box |[ V vs=1 [V vs=0 [~*imports] V vs=1 [~*types]] ]|

  java-to-box:
    PackageDec(annos, name) -> V hs=0 [~*annos H [KW["package"] H hs=0 [~name ";"]]]

rules

  java-to-box:
    TypeImportDec(tname) -> H [KW["import"] H hs=0 [~tname ";"]]

  java-to-box:
    TypeImportOnDemandDec(pname) -> H hs=1 [KW["import"] H hs=0 [~pname ".*;"]]

  java-to-box:
    StaticImportDec(tname, Id(s)) -> H hs=1 [KW["import"] KW["static"] H hs=0 [~tname "." s ";"]] 

  java-to-box:
    StaticImportOnDemandDec(tname)  -> H hs=1 [KW["import"] KW["static"] H hs=0 [~tname "." "*" ";"]] 

rules

  java-to-box:
    Semicolon() -> box |[ ";" ]|

  java-to-box:
    InterfaceDec(InterfaceDecHead(mods, Id(name), type-args, implements), body)
      ->
    V vs=0 [H hs=1 [ ~*mods KW["interface"] b* ~lit:name ~implements] b2]
    where
      <type-args-to-boxes> type-args => b*
    ; <block-structure> (1, body) => b2

  java-to-box:
    ClassDec(ClassDecHead(mods, Id(name), None(), extends, implements), body)
      ->
    V vs=0 [H hs=1 [~*mods KW["class"] ~lit:name ~extends ~implements] ~body]

  java-to-box:
    ClassBody(decs) -> <block-structure> (1, decs)

  // TODO: use the integer in the vs.
  block-structure:
    (1, elems) -> box |[ V vs=0 [H hs=1 ["{" V vs=0 ["" V vs=1 [~*elems]]] "}"] ]|
    where
      <not-empty> elems

  block-structure:
    (0, elems) -> box |[ V vs=0 [H hs=1 ["{" V vs=0 ["" V vs=0 [~*elems]]] "}"] ]|
      where
        <not-empty> elems

  block-structure:
    (_, []) -> box |[ H hs=1 ["{" "}"] ]|

  not-empty =
    not(?[])

  java-to-box:
    None() -> box |[ H hs=0 [""] ]|

  java-to-box:
    Some(c) -> c

  java-to-box:
    SuperDec(c) -> box |[ H hs=1 [KW["extends"] ~c] ]|

  java-to-box:
    ImplementsDec(is) -> box |[ H hs=1 [KW["implements"] ~interfaces] ]|
      where <separate-by-comma> is; ?interfaces

  java-to-box:
    ExtendsInterfaces(is) -> box |[ H hs=1 [KW["extends"] ~interfaces] ]|
      where <separate-by-comma> is; ?interfaces

rules

  hbox = 
      ( is-list < id + ![<id>])
    ; !box |[ H hs=0 [ ~*<id> ] ]|

  comma = 
    !box |[ "," ]|

  point = 
    !box |[ "." ]|

  list-to-args:
    [] -> box |[ H hs=0 ["(" ")"] ]|

  list-to-args:
    exprs@[_ | _ ] -> box |[ H hs=0 ["(" ~args ")"] ]|
    where
      <separate-by-comma> exprs => args

  separate-by-comma =
    rec x(
      ?[<id>]
    <+ \ [] -> H hs=0 [] \
    <+ {b1, b2:
         ?[b1 | <x>]
       ; ?b2
       ; !H hs=1 [H hs=0 [b1 ","] b2]
       }
    )

rules

  java-to-box:
    StaticInit(b)   -> box |[ V vs=0 [KW["static"] ~b] ]|

  java-to-box:
    InstanceInit(b) -> b

rules

  java-to-box:
    MethodDec(dec, b@Block(_)) -> V vs=0 [~dec b]

  java-to-box:
    MethodDec(dec, NoMethodBody()) -> H hs=0 [~dec ";"]

  java-to-box:
    AbstractMethodDec(mods, type-params, type, Id(n), params, throws)
      ->
    box |[ H hs=0 [ ~MethodDecHead(mods, type-params, type, Id(n), params, throws) ";" ] ]|

  java-to-box:
    MethodDecHead(mods, type-params, type, Id(n), params, None())
      ->
    box |[ H hs=1 [~*foo ~type H hs=0 [~lit:n ~args]] ]|
    where
      <list-to-args> params => args
    ; <type-args-to-boxes> type-params => targboxes
    ; !Conc(mods, targboxes) => foo

  java-to-box:
    MethodDecHead(mods, type-params, type, Id(n), params, Some(throws))
      ->
    box |[ H hs=1 [~*foo ~type H hs=0 [~lit:n ~args] ~throws] ]|
    where
      <list-to-args> params => args
    ; <type-args-to-boxes> type-params => targboxes
    ; !Conc(mods, targboxes) => foo

  java-to-box:
    DeprMethodDecHead(mods, type-params, type, Id(n), params, dims, throws)
      ->
    H hs=1 [~*mods ~type b* H hs=0 [~lit:n ~args] H hs=0 [~*dims] ~throws]
    where
      <list-to-args> params => args
    ; <type-args-to-boxes> type-params => b*

  java-to-box:
    ConstrDec(ConstrDecHead(mods, type-params, class, params, throws), body)
      ->
    V vs=0 [H hs=1 [~*foo ~class ~args ~throws] ~body]
    where
      <list-to-args> params => args
    ; <type-args-to-boxes> type-params => targboxes
    ; !Conc(mods, targboxes) => foo

  java-to-box:
    ConstrBody(None(), stms) -> <block-structure> (0, stms)

  java-to-box:
    ConstrBody(Some(cinvoke), stms) -> <block-structure> (0, [cinvoke | stms])

  java-to-box:
    Param(mods, type, vardecid) -> H hs=1 [~*mods ~type ~vardecid]

  java-to-box:
    ThrowsDec(exceptions) -> H hs=1 [KW["throws"] ~excs]
    where
      <separate-by-comma> exceptions => excs

  java-to-box:
    FieldDec(mods, type, ds)
      ->
    H hs=1 [~*mods ~type H hs=0 [~decs ";"]]
    where
      <separate-by-comma> ds => decs

  java-to-box:
    ConstantDec(mods, type, ds) -> FieldDec(mods, type, ds)

  java-to-box:
    VarDec(i) -> i

  java-to-box:
    VarDec(i, init) -> H hs=1 [~i "=" ~init]

  java-to-box:
    Id(s) -> box |[ s ]|

  java-to-box:
    ArrayVarDecId(Id(s), b*) -> H hs=0 [s b*]

  java-to-box:
    Dim() -> H hs=0 ["[" "]"]

  java-to-box:
    Dim(e) -> H hs=0 ["[" ~e "]"]

  java-to-box:
    ArrayInit(exprs) -> H hs=0 ["{" ~vals "}"]
    where
      <separate-by-comma> exprs => vals

  java-to-box:
    AltConstrInv(type-args, exprs) -> H hs=0 [~*b1* KW["this"] ~args ";"]
    where
      <list-to-args> exprs => args
    ; <type-args-to-boxes> type-args => b1*

  java-to-box:
    SuperConstrInv(type-args, exprs) -> box |[ H hs=0 [~*b1* KW["super"] b2 ";"] ]|
    where
      <list-to-args> exprs => b2
    ; <type-args-to-boxes> type-args => b1*

  java-to-box:
    QSuperConstrInv(b0, type-args, exprs) -> box |[ H hs=0 [b0 "." b1* KW["super"] b2 ";"] ]|
    where
      <list-to-args> exprs => b2
    ; <type-args-to-boxes> type-args => b1*
