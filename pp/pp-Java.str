module pp-Java
imports
  liblib
  Box
  Java
  concrete-syntax
  java-parenthesize
  pp-Java-Statements
  pp-Java-Expressions
  pp-Java-Literals 
  pp-Java-Names
  pp-Java-Modifiers
  pp-Generic-Java

strategies

  java-pretty-print = 
      parenthesize-Java
    ; topdown(try(repeat(java-to-box)))
    ; concat-content

strategies

  java-to-box: ClassType(t)     -> t
  java-to-box: InterfaceType(t) -> t
  java-to-box: ArrayType(t)    -> box |[ H hs=0 [~t "[" "]"] ]|

  java-to-box: Void()    -> box |[ KW["void"] ]|

  java-to-box: Boolean() -> box |[ KW["boolean"] ]|
  java-to-box: Byte()    -> box |[ KW["byte"]    ]|
  java-to-box: Short()   -> box |[ KW["short"]   ]|
  java-to-box: Int()     -> box |[ KW["int"]     ]|
  java-to-box: Long()    -> box |[ KW["long"]    ]|
  java-to-box: Char()    -> box |[ KW["char"]    ]|
  java-to-box: Float()   -> box |[ KW["float"]   ]|
  java-to-box: Double()  -> box |[ KW["double"]  ]|

  java-to-box:
    CompilationUnit(Some(package), imports, types) -> box |[ V vs=1 [~package V vs=0 [ ~*imports ] V vs=1 [ ~*types ]] ]|

  java-to-box:
    CompilationUnit(None(), imports, types) -> box |[ V vs=1 [V vs=0 [~*imports] V vs=1 [~*types]] ]|

  java-to-box:
    PackageDec(name) -> box |[ H [KW["package"] H hs=0 [~name ";"]] ]|

rules

  java-to-box:
    ImportDec(r) ->  r

  java-to-box:
    TypeRef(tname) -> box |[ H [KW["import"] H hs=0 [~tname ";"]] ]|

  java-to-box:
    PackageRef(pname) -> box |[ H hs=1 [KW["import"] H hs=0 [~pname ".*;"]] ]|

  java-to-box:
    TypeMemberRef(tname, Id(s)) -> box |[ H hs=1 [KW["import"] KW["static"] H hs=0 [~tname "." s ";"]] ]|
  java-to-box:
    TypeMembersRef(tname)  -> box |[ H hs=1 [KW["import"] KW["static"] H hs=0 [~tname "." "*" ";"]] ]|

rules

  java-to-box:
    Semicolon() -> box |[ "" ]|

  java-to-box:
    InterfaceDec(mods, Id(name), implements, body)
      ->
    box |[ V vs=0 [H hs=1 [ ~*mods KW["interface"] ~lit:name ~implements] ~body] ]|

  java-to-box:
    ClassDec(mods, Id(name), extends, implements, body)
      ->
    box |[ V vs=0 [H hs=1 [~*mods KW["class"] ~lit:name ~extends ~implements] ~body] ]|

  java-to-box: InterfaceBody(decs) -> <block-structure> (1, decs)
  java-to-box: ClassBody(decs)     -> <block-structure> (1, decs)

  // TODO: use the integer in the vs.
  block-structure:
    (1, elems) -> box |[ V vs=0 [H hs=1 ["{" V vs=0 ["" V vs=1 [~*elems]]] "}"] ]|
      where <not-empty> elems

  block-structure:
    (0, elems) -> box |[ V vs=0 [H hs=1 ["{" V vs=0 ["" V vs=0 [~*elems]]] "}"] ]|
      where <not-empty> elems

  block-structure:
    (_, []) -> box |[ H hs=1 ["{" "}"] ]|

  not-empty = not(?[])

  java-to-box:
    None() -> box |[ H hs=0 [""] ]|

  java-to-box:
    Some(c) -> c
  
  java-to-box:
    Extends(c) -> box |[ H hs=1 [KW["extends"] ~c] ]|

  java-to-box:
    Implements(is) -> box |[ H hs=1 [KW["implements"] ~interfaces] ]|
      where <separate-by-comma> is; ?interfaces

  java-to-box:
    ExtendsInterfaces(is) -> box |[ H hs=1 [KW["extends"] ~interfaces] ]|
      where <separate-by-comma> is; ?interfaces

  hbox = 
      ( is-list < id + ![<id>])
    ; !box |[ H hs=0 [ ~*<id> ] ]|

  comma = 
    !box |[ "," ]|

  point = 
    !box |[ "." ]|

  list-to-args:
    exprs -> box |[ H hs=0 ["(" ~args ")"] ]|
      where <not-empty> exprs
          ; <separate-by-comma> exprs => args

  separate-by-comma =
    rec x(
      ?[<id>]
    <+ \ [] -> H hs=0 [] \
    <+ {b1, b2:
         ?[b1 | <x>]
       ; ?b2
       ; !H hs=1 [H hs=0 [b1 ","] b2]
       }
    )

  list-to-args:
    [] -> box |[ H hs=1 ["(" ")"] ]|

  java-to-box:
    StaticInit(b)   -> box |[ V vs=0 [KW["static"] ~b] ]|
  java-to-box:
    InstanceInit(b) -> b


  java-to-box:
    MethodDec(dec, body) -> box |[ V vs=0 [~dec ~body] ]|
  java-to-box:
    MethodDec(dec)       -> box |[ H hs=0 [~dec ";"] ]|

  /**
   * @todo  support pretty-printing of DeprHead?
   */
  java-to-box:
    Head(mods, type, Id(n), params, throws)
      ->
    box |[ H hs=1 [~*mods ~type ~lit:n ~args ~throws] ]|
      where <list-to-args> params => args

  java-to-box:
    ConstructorDec(mods, class, params, throws, body)
      ->
    box |[ V vs=0 [H hs=1 [~*mods ~class ~args ~throws] ~body] ]|
      where <list-to-args> params => args

  java-to-box:
    ConstructorBody(None(), stms) -> <block-structure> (0, stms)

  java-to-box:
    ConstructorBody(Some(cinvoke), stms) -> <block-structure> (0, [cinvoke | stms])

  java-to-box:
    Param(None(), type, vardecid) -> box |[ H hs=1 [~type ~vardecid] ]|

  java-to-box:
    Param(Some(Final()), type, vardecid) -> box |[ H hs=1 [KW["final"] ~type ~vardecid] ]|

  java-to-box:
    Throws(exceptions) -> box |[ H hs=1 [KW["throws"] ~excs] ]|
      where <separate-by-comma> exceptions => excs

  java-to-box:
    FieldDec(mods, type, ds)
      ->
    box |[ H hs=1 [~*mods ~type H hs=0 [~decs ";"]] ]|
      where <separate-by-comma> ds => decs

  java-to-box:
    ConstantDec(mods, type, ds) -> FieldDec(mods, type, ds)

  java-to-box:
    VarDec(i) -> i

  java-to-box:
    VarDec(i, init) -> box |[ H hs=1 [~i "=" ~init] ]|

  java-to-box:
    VarId(Id(s)) -> box |[ s ]|

  java-to-box:
    VarId(Id(s), b*) -> box |[ H hs=0 [s b*] ]|

  java-to-box:
    Dim() -> box |[ H hs=0 ["[" "]"] ]|

  java-to-box:
    Dim(e) -> box |[ H hs=0 ["[" ~e "]"] ]|

  java-to-box:
    ArrayInit(exprs, _) -> box |[ H hs=0 ["{" ~vals "}"] ]| 
      where <separate-by-comma> exprs => vals

  java-to-box:
    CInvoke(exprs) -> box |[ H hs=0 [KW["this"] ~args ";"] ]|
      where <list-to-args> exprs => args

  java-to-box:
    SuperCInvoke(exprs) -> box |[ H hs=0 [KW["super"] ~args ";"] ]|
      where <list-to-args> exprs => args

  java-to-box:
    QSuperCInvoke(q, exprs) -> box |[ H hs=0 [~q "." KW["super"] ~args ";"] ]|
      where <list-to-args> exprs => args