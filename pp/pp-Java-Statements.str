module pp-Java-Statements
rules

  stm-box:
    x -> box |[ H hs=0 [~x ";"] ]|

  java-to-box:
    Block(stms) -> <block-structure> (0, stms)

  java-to-box: Return(None())  -> <stm-box> box |[  KW["return"] ]|
  java-to-box: Return(Some(e)) -> <stm-box> box |[ H hs=1 [KW["return"] ~e] ]|

  //TODO: remove call to expr-to-box when the pretty-printing of expressions handles priorities
  java-to-box: Expr(e)  -> <try(expr-to-box); stm-box> e
  java-to-box: Empty()  -> box |[ ";" ]|

rules

  /**
   * LocalVarDecStm
   */
  java-to-box=
    ?LocalVarDec(type, ds)
    ; LocalVarDec-to-box
    ; stm-box

  LocalVarDec-to-box :
    LocalVarDec(type, ds) -> H hs=1 [~type ~decs]
      where <separate-by-comma> ds => decs

  LocalVarDec-to-box :
    FinalLocalVarDec(type, decs) -> H hs=1 [KW["final"] ~LocalVarDec(type, decs) ]

rules

  java-to-box:
    Try(block, catches) -> V vs=0 [KW["try"] ~block ~*catches]

  java-to-box:
    Try(block, catches, finally)
      ->
    V vs=0 [KW["try"] ~block ~*catches KW["finally"] ~finally]

  java-to-box:
    Catch(param, block)
      ->
     V vs=0 [H hs=0 [KW["catch"] "(" ~param ")"] ~block]

  java-to-box:
    Throw(e) -> H hs=1 [KW["throw"] H hs=0[~e ";" ]]

/**
 * if and if-else
 */
rules

  java-to-box =
    ?If(_, _)
    ; if-then-to-box

  java-to-box:
    If(b1, b2, b3) -> V vs=0 [b4 b5]
      where <if-then-to-box> If(b1, b2) => b4
          ; <if-else-to-box> If(b1, b2, b3) => b5

  if-then-to-box :
    If(b1, b2) -> V is=2 vs=0 [H hs=0 [KW["if"] "(" b1 ")"] b2]
      where not(!b2 => Block(_))

  if-then-to-box :
    If(b1, b2) -> V vs=0 [H hs=0 [KW["if"] "(" b1 ")"] b2]
      where !b2 => Block(_)

  if-else-to-box :
    If(b1, b2, b3) -> V is=2 vs=0 [KW["else"] b3]
      where not(!b3 => Block(_))

  if-else-to-box :
    If(b1, b2, b3) -> V vs=0 [KW["else"] b3]
      where !b3 => Block(_)

rules

  ensure-block =
    ?Block(_) < id + !Block([<id>])

  java-to-box:
    While(cond, body) -> box |[ V vs=0 [H hs=0 [KW["while"] "(" ~cond ")"] ~b] ]|
      where <ensure-block> body => b

  java-to-box:
    DoWhile(body, cond) -> box |[ V vs=0 [KW["do"] ~b H hs=0 [KW["while"] "(" ~cond ")" ";"]] ]|
      where <ensure-block> body => b

  java-to-box:
    For(init, cond, update, body) ->
      box |[ V vs=0[H hs=0 [KW["for"] "(" ~*binit ";" ~*bcond ";" ~*bupdate ")"] ~body] ]|

        where < map(java-to-box)
              ; separate-by(comma)
              > update => bupdate

            ; < LocalVarDec-to-box; ![<id>]
                <+ map(java-to-box)
                 ; separate-by(comma)
              > init => binit

            ; < ?Some(<id>); java-to-box; ![<id>]
                <+ ?None(); ![]
              > cond => bcond

  java-to-box:
    Synchronized(e, b) -> box |[ V vs=0 [H hs=0 [KW["synchronized"] "(" ~e ")"] ~b] ]|

  java-to-box: Break(Some(s)) -> box |[ H hs=0 [H hs=1 [KW["break"] ~lit:s] ";"] ]| 
  java-to-box: Break(None())  -> box |[ H hs=0 [KW["break"] ";"] ]| 

  java-to-box: Continue(Some(s)) -> box |[ H hs=0 [H hs=1 [KW["continue"] ~lit:s] ";"] ]| 
  java-to-box: Continue(None())  -> box |[ H hs=0 [KW["continue"] ";"] ]| 

  java-to-box:
    Labeled(s, stm) -> box |[ H hs=1 [~lit:s ":" ~stm] ]| 

  java-to-box:
    Assert(e) -> box |[ H hs=0 [H hs=1 [KW["assert"] ~e] ";"] ]| 

  java-to-box:
    Assert(e1, e2) -> H hs=0 [H hs=1 [KW["assert"] ~e1 ":" ~e2] ";"]

  java-to-box:
    Switch(b1, b2) -> V vs=0 [H hs=0 [KW["switch"] "(" b1 ")"] b2]

  java-to-box:
    SwitchBlock(groups, labels) ->
      <block-structure> (1, <conc> (groups, labels))

  java-to-box:
    SwitchGroup(labels, stms) -> V is=2 vs=0 [ V vs=0 [~*labels] ~*stms ]

  java-to-box:
    Case(e) -> H hs=0 [H hs=1 [KW["case"] ~e] ":"]

  java-to-box:
    Default() -> H hs=0 [KW["default"] ":"]

