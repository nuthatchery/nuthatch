module pp-Java-Expressions

strategies

  java-to-box =
    expr-to-box

  java-to-box: Lit(l) -> l

  expr-to-box: Parenthetical(e)           -> box |[ H hs=0 ["(" ~e ")"] ]|
  expr-to-box: Assign(lval, e)            -> box |[ H hs=1 [~lval "="    ~e] ]|
  expr-to-box: AssignMul(lval, e)         -> box |[ H hs=1 [~lval "*="   ~e] ]|
  expr-to-box: AssignDiv(lval, e)         -> box |[ H hs=1 [~lval "/="   ~e] ]|
  expr-to-box: AssignRemain(lval, e)      -> box |[ H hs=1 [~lval "%="   ~e] ]|
  expr-to-box: AssignPlus(lval, e)        -> box |[ H hs=1 [~lval "+="   ~e] ]|
  expr-to-box: AssignMinus(lval, e)       -> box |[ H hs=1 [~lval "-="   ~e] ]|
  expr-to-box: AssignLeftShift(lval, e)   -> box |[ H hs=1 [~lval "<<="  ~e] ]|
  expr-to-box: AssignRightShift(lval, e)  -> box |[ H hs=1 [~lval ">>="  ~e] ]|
  expr-to-box: AssignURightShift(lval, e) -> box |[ H hs=1 [~lval ">>>=" ~e] ]|
  expr-to-box: AssignAnd(lval, e)         -> box |[ H hs=1 [~lval "&="   ~e] ]|
  expr-to-box: AssignExcOr(lval, e)       -> box |[ H hs=1 [~lval "^="   ~e] ]|
  expr-to-box: AssignOr(lval, e)          -> box |[ H hs=1 [~lval "|="   ~e] ]|

  expr-to-box: Plus(e)     -> box |[ H hs=0 [   "+"  ~e] ]|
  expr-to-box: Minus(e)    -> box |[ H hs=0 [   "-"  ~e] ]|
  expr-to-box: PreIncr(e)  -> box |[ H hs=0 [   "++" ~e] ]|
  expr-to-box: PreDecr(e)  -> box |[ H hs=0 [   "--" ~e] ]|
  expr-to-box: PostIncr(e) -> box |[ H hs=0 [~e "++"   ] ]|
  expr-to-box: PostDecr(e) -> box |[ H hs=0 [~e "--"   ] ]|

  expr-to-box: Mul(e1, e2)          -> box |[ H hs=1 [~e1  "*"   ~e2] ]|
  expr-to-box: Div(e1, e2)          -> box |[ H hs=1 [~e1  "/"   ~e2] ]|
  expr-to-box: Remain(e1, e2)       -> box |[ H hs=1 [~e1  "%"   ~e2] ]|
  expr-to-box: Plus(e1, e2)         -> box |[ H hs=1 [~e1  "+"   ~e2] ]|
  expr-to-box: Minus(e1, e2)        -> box |[ H hs=1 [~e1  "-"   ~e2] ]|
  expr-to-box: LeftShift(e1, e2)    -> box |[ H hs=1 [~e1  "<<"  ~e2] ]|
  expr-to-box: RightShift(e1, e2)   -> box |[ H hs=1 [~e1  ">>"  ~e2] ]|
  expr-to-box: URightShift(e1, e2)  -> box |[ H hs=1 [~e1  ">>>" ~e2] ]|

  expr-to-box: Lt(e1, e2)           -> box |[ H hs=1 [~e1  "<"   ~e2] ]|
  expr-to-box: Gt(e1, e2)           -> box |[ H hs=1 [~e1  ">"   ~e2] ]|
  expr-to-box: LtEq(e1, e2)         -> box |[ H hs=1 [~e1  "<="  ~e2] ]|
  expr-to-box: GtEq(e1, e2)         -> box |[ H hs=1 [~e1  ">="  ~e2] ]|
  expr-to-box: Eq(e1, e2)           -> box |[ H hs=1 [~e1  "=="  ~e2] ]|
  expr-to-box: NotEq(e1, e2)        -> box |[ H hs=1 [~e1  "!="  ~e2] ]|
  expr-to-box: LazyAnd(e1, e2)      -> box |[ H hs=1 [~e1  "&&"  ~e2] ]|
  expr-to-box: LazyOr(e1, e2)       -> box |[ H hs=1 [~e1  "||"  ~e2] ]|
  expr-to-box: And(e1, e2)          -> box |[ H hs=1 [~e1  "&"   ~e2] ]|
  expr-to-box: ExcOr(e1, e2)        -> box |[ H hs=1 [~e1  "^"   ~e2] ]|
  expr-to-box: Or(e1, e2)           -> box |[ H hs=1 [~e1  "|"   ~e2] ]|

  expr-to-box: InstanceOf(e1, e2)   -> box |[ H hs=1 [~e1 "instanceof" ~e2] ]|

  expr-to-box: Complement(e)         -> box |[ H hs=0 ["~" ~e] ]|
  expr-to-box: Not(e)                -> box |[ H hs=0 ["!" ~e] ]|
  expr-to-box: Cond(e1, e2, e3)    -> box |[ H hs=1 [~e1  "?" ~e2 ":"  ~e3] ]|

  /* java-to-box: Name(s) -> s */

  java-to-box: This()   -> box |[ KW["this"] ]|
  java-to-box: QThis(q) -> box |[ H hs=0 [~q "." KW["this"]] ]|

  java-to-box: 
    Invoke(method, exprs) -> box |[ H hs=0 [~method ~args] ]|
      where <list-to-args> exprs => args

  java-to-box: 
    Method(n) -> n

  java-to-box: 
    Method(e, Id(i)) -> box |[ H hs=0 [~e "." ~S(i)] ]|

  java-to-box: 
    SuperMethod(Id(i)) -> box |[ H hs=0 [KW["super"] "." ~S(i)] ]|

  java-to-box: 
    QSuperMethod(q, Id(i)) -> box |[ H hs=0 [~q "." KW["super"] "." ~S(i)] ]|

  java-to-box: 
    NewInstance(type, exprs, None()) -> box |[ H hs=0 [H hs=1 [KW["new"] ~type] ~args] ]|
      where <list-to-args> exprs => args

  java-to-box: 
    QNewInstance(e, n, exprs, None()) -> box |[ H hs=0 [~e "." H hs=1 [KW["new"] ~S(n)] ~args] ]|
      where <list-to-args> exprs => args

  java-to-box: 
    NewInstance(type, exprs, Some(body)) -> box |[ V vs=0[H hs=0 [H hs=1 [KW["new"] ~type] ~args] ~body] ]|
      where <list-to-args> exprs => args

  java-to-box: 
    QNewInstance(e, n, exprs, Some(body)) -> box |[ V vs=0 [H hs=0 [~e "." H hs=1 [KW["new"] ~S(n)] ~args] ~body] ]|
      where <list-to-args> exprs => args

  java-to-box: 
    NewArray(type, dimexprs, dims) -> box |[ H hs=0 [H hs=1 [KW["new"] ~type] ~*dimexprs ~*dims] ]|

  java-to-box: 
    NewArray(type, dims, init@ArrayInit(_, _)) -> box |[ H hs=0 [H hs=1 [KW["new"] ~type] ~*dims ~init] ]|

  java-to-box: 
    ArrayAccess(e1, e2) -> box |[ H hs=0 [ ~e1 "[" ~e2 "]"] ]|

  java-to-box: 
    Cast(t, e) -> box |[ H hs=0 ["(" ~t ")" ~e] ]|

  java-to-box: 
    Field(e, n) -> box |[ H hs=0 [~e "." ~S(n)] ]|

  java-to-box: 
    SuperField(n) -> box |[ H hs=0 [KW["super"] "." ~S(n)] ]|

  java-to-box: 
    QSuperField(q, n) -> box |[ H hs=0 [~q "." KW["super"] "." ~S(n)] ]|
